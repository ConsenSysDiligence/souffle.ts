import { Fact } from "./fact";
import { Relation } from "./relation";
import { assert, createTableForRelation, repeat } from "./utils";
import { join } from "path";
import { open, Database } from "sqlite";
import { parse } from "csv-parse/sync";
import { stringify } from "csv-stringify/sync";
import sqlite3 from "sqlite3";
import fse from "fs-extra";
import os from "os";

export type FactMap = Map<string, Fact[]>;

/**
 * Set of Facts (from multiple relations) that is backed by files (csv or
 * sqlite) in a temporary directory.  This object holds a reference to the
 * temporary directory - by calling `release()` the directory is deleted.
 *
 * Ths object can be used for both reading .csv/.sqlite files generated by
 * souffle, as well as dumping input facts to new .csv/.sqlite files for use by
 * souffle.
 */
export abstract class FactSet {
    protected _relationMap: Map<string, Relation>;
    public readonly directory: string;

    constructor(
        public readonly relations: Relation[],
        _directory?: string
    ) {
        if (!_directory) {
            const sysTmpDir = os.tmpdir();
            _directory = fse.mkdtempSync(join(sysTmpDir, "sol-datalog-"));
        }

        this.directory = _directory;

        this._relationMap = new Map(relations.map((r) => [r.name, r]));
    }

    relation(name: string): Relation {
        const res = this._relationMap.get(name);
        assert(res !== undefined, `Unknown relation ${name}`);

        return res;
    }

    abstract facts(name: string): Promise<Fact[]>;
    abstract allFacts(): Promise<FactMap>;
    abstract addFacts(...facts: Fact[]): void;

    // Persist all local fact changes to disk
    abstract persist(): Promise<void>;

    release(): void {
        fse.rmSync(this.directory, { recursive: true });
    }
}

/**
 * A FactSet that caches *all* the facts any one relation in memory
 */
export abstract class CachedFactSet extends FactSet {
    private _factCache: FactMap = new Map();

    addFacts(...facts: Fact[]): void {
        for (const f of facts) {
            const reln = f.relation;

            if (!this._relationMap.has(reln.name)) {
                this._relationMap.set(reln.name, reln);
            }

            if (!this._factCache.has(reln.name)) {
                this._factCache.set(reln.name, []);
            }

            (this._factCache.get(reln.name) as Fact[]).push(f);
        }
    }

    async facts(name: string): Promise<Fact[]> {
        const reln = this.relation(name);
        let res = this._factCache.get(name);

        if (res) {
            return res;
        }

        res = await this.loadRelation(reln);
        this._factCache.set(name, res);

        return res;
    }

    async allFacts(): Promise<FactMap> {
        for (const reln of this._relationMap.values()) {
            if (!this._factCache.has(reln.name)) {
                const facts = await this.loadRelation(reln);
                this._factCache.set(reln.name, facts);
            }
        }

        return this._factCache;
    }

    initializeEmpty(): void {
        for (const reln of this._relationMap.values()) {
            this._factCache.set(reln.name, []);
        }
    }

    abstract loadRelation(reln: Relation): Promise<Fact[]>;
    abstract dumpRelation(reln: Relation): Promise<void>;

    async persist(): Promise<void> {
        for (const reln of this._relationMap.values()) {
            await this.dumpRelation(reln);
        }
    }
}

function parseCSV(content: string): string[][] {
    return parse(content, {
        skipEmptyLines: true,
        cast: false,
        delimiter: ","
    });
}

/**
 * FactSet backed by CSV files.
 */
export class CSVFactSet extends CachedFactSet {
    async loadRelation(relation: Relation): Promise<Fact[]> {
        const fileName = join(this.directory, relation.name + ".csv");

        const content = fse.readFileSync(fileName, { encoding: "utf-8" });
        const entries = parseCSV(content);

        return Fact.fromCSVRows(relation, entries);
    }

    async dumpRelation(relation: Relation): Promise<void> {
        const fileName = join(this.directory, relation.name + ".csv");

        const facts = await this.facts(relation.name);
        const csv = facts.length > 0 ? Fact.toCSVRows(facts) : [];

        fse.writeFileSync(fileName, stringify(csv));
    }
}

/**
 * FactSet backed by SQLite database.
 */
export class SQLFactSet extends CachedFactSet {
    private _db!: Database;
    private _dbFileNAme: string;

    constructor(
        public readonly relations: Relation[],
        directory?: string,
        dbName: string = "facts.db"
    ) {
        super(relations, directory);
        this._dbFileNAme = join(this.directory, dbName);
    }

    async db(): Promise<Database> {
        if (this._db === undefined) {
            this._db = await open({
                filename: this._dbFileNAme,
                driver: sqlite3.Database
            });
        }

        return this._db;
    }

    async loadRelation(relation: Relation): Promise<Fact[]> {
        const db = await this.db();
        const rawRes = await db.all(`SELECT * from ${relation.name}`);

        return Fact.fromSQLRows(relation, rawRes);
    }

    async dumpRelation(relation: Relation): Promise<void> {
        const db = await this.db();
        const facts = await this.facts(relation.name);
        await createTableForRelation(db, relation);

        if (facts.length === 0) {
            return;
        }

        const sqlVals = Fact.toSQLRows(facts);
        const stmt = await db.prepare(
            `INSERT INTO ${relation.name} VALUES (${repeat("?", relation.fields.length).join(", ")})`
        );

        for (const val of sqlVals) {
            await stmt.run(...val);
        }
    }
}
